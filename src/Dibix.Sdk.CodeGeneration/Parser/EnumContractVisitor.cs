using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using Dibix.Sdk.Abstractions;
using Dibix.Sdk.Sql;
using Microsoft.SqlServer.TransactSql.ScriptDom;

namespace Dibix.Sdk.CodeGeneration
{
    internal sealed class EnumContractVisitor : TSqlFragmentVisitor
    {
        private readonly string _file;
        private readonly string _productName;
        private readonly string _areaName;
        private readonly ILogger _logger;

        public EnumSchema Definition { get; private set; }

        public EnumContractVisitor(string file, string productName, string areaName, ILogger logger)
        {
            _file = file;
            _productName = productName;
            _areaName = areaName;
            _logger = logger;
        }

        public override void ExplicitVisit(CreateTableStatement node)
        {
            if (node.IsTemporaryTable())
                return;

            ISqlMarkupDeclaration markup = SqlMarkupReader.Read(node, SqlMarkupCommentKind.SingleLine, _file, _logger);
            if (!markup.TryGetSingleElementValue(SqlMarkupKey.Enum, _file, _logger, out Token<string> enumContractName))
                return;

            _ = markup.TryGetSingleElementValue(SqlMarkupKey.Namespace, _file, _logger, out string relativeNamespace);
            EnumSchema definition = CollectEnumSchema(node, enumContractName, relativeNamespace);

            if (Definition != null)
                _logger.LogError("Only one definition per file is supported", definition.Location);

            Definition = definition;
        }

        private EnumSchema CollectEnumSchema(CreateTableStatement createTableStatement, Token<string> enumContractName, string relativeNamespace)
        {
            TableDefinition definition = createTableStatement.Definition;
            IEnumerable<CheckConstraintDefinition> checkConstraints = definition.TableConstraints
                                                                                .Concat(definition.ColumnDefinitions.SelectMany(x => x.Constraints))
                                                                                .OfType<CheckConstraintDefinition>();
            
            foreach (CheckConstraintDefinition checkConstraint in checkConstraints)
            {
                if (TryCollectEnumSchema(enumContractName, relativeNamespace, checkConstraint.CheckCondition, out EnumSchema enumSchema))
                    return enumSchema;
            }

            return null;
        }

        private bool TryCollectEnumSchema(Token<string> enumContractName, string relativeNamespace, BooleanExpression checkCondition, out EnumSchema enumSchema)
        {
            TargetPath targetPath = PathUtility.BuildAbsoluteTargetName(_productName, _areaName, LayerName.DomainModel, relativeNamespace, targetNamePath: enumContractName);
            EnumSchema schema = new EnumSchema(targetPath.AbsoluteNamespace, enumContractName, SchemaDefinitionSource.AutoGenerated, enumContractName.Location, isFlaggable: false);

            switch (checkCondition)
            {
                case InPredicate { Expression: ColumnReferenceExpression } inPredicate when inPredicate.Values.All(x => x is Literal):
                    CollectSchemaMembers(schema, inPredicate);
                    break;

                case BooleanBinaryExpression booleanBinaryExpression when TryCollectSchemaMembers(schema, booleanBinaryExpression):
                    break;

                case BooleanComparisonExpression booleanComparisonExpression when TryCollectSchemaMembers(schema, booleanComparisonExpression):
                    break;

                default:
                    enumSchema = null;
                    return false;
            }

            enumSchema = schema;
            return true;
        }

        private static bool TryCollectSchemaMembers(EnumSchema schema, BooleanComparisonExpression comparisonExpression)
        {
            if (comparisonExpression.FirstExpression is not ColumnReferenceExpression)
                return false;

            if (GetInnerExpression(comparisonExpression.SecondExpression) is not Literal literal)
                return false;

            if (!TryCollectSchemaMember(schema, comparisonExpression.SecondExpression, literal))
                return false;

            return true;
        }

        private static bool TryCollectSchemaMembers(EnumSchema schema, BooleanBinaryExpression booleanBinaryExpression)
        {
            if (booleanBinaryExpression.SecondExpression is not BooleanComparisonExpression comparisonExpression)
                return false;

            if (!TryCollectSchemaMembers(schema, comparisonExpression))
                return false;

            if (booleanBinaryExpression.FirstExpression is BooleanBinaryExpression binaryExpression)
                return TryCollectSchemaMembers(schema, binaryExpression);
            
            if (booleanBinaryExpression.FirstExpression is not BooleanComparisonExpression anotherComparisonExpression)
                return false;

            if (!TryCollectSchemaMembers(schema, anotherComparisonExpression))
                return false;

            return true;
        }

        private static void CollectSchemaMembers(EnumSchema schema, InPredicate inPredicate)
        {
            foreach (Literal literal in inPredicate.Values.Cast<Literal>())
            {
                if (!TryCollectSchemaMember(schema, literal, literal))
                    return;
            }
        }

        private static bool TryCollectSchemaMember(EnumSchema schema, TSqlFragment container, Literal literal)
        {
            if (!Int32.TryParse(literal.Value, out int memberValue))
                return false;

            if (!TryParseEnumMemberName(container, out string memberName))
                return false;

            schema.Members.Add(new EnumSchemaMember(memberName, memberValue, stringValue: memberValue.ToString(CultureInfo.InvariantCulture), schema));
            return true;
        }

        private static bool TryParseEnumMemberName(TSqlFragment node, out string name)
        {
            for (int i = node.LastTokenIndex + 1; i < node.ScriptTokenStream.Count; i++)
            {
                TSqlParserToken token = node.ScriptTokenStream[i];
                switch (token.TokenType)
                {
                    case TSqlTokenType.WhiteSpace:
                        continue;

                    case TSqlTokenType.SingleLineComment:
                        Match match = Regex.Match(token.Text, @"^--[\s]+(?<name>[\w]+)");
                        name = match.Groups["name"].Value;
                        return !String.IsNullOrWhiteSpace(name);

                    default:
                        name = null;
                        return false;
                }
            }

            name = null;
            return false;
        }

        private static ScalarExpression GetInnerExpression(ScalarExpression expression)
        {
            ScalarExpression result = expression;
            while (result is ParenthesisExpression parenthesisExpression)
            {
                result = parenthesisExpression.Expression;
            }
            return result;
        }
    }
}