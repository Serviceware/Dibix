using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace Dibix.Generators
{
    internal static class GenerationUtility
    {
        private const string EmbeddedSourcePrefix = $"{nameof(Dibix)}.{nameof(Generators)}.EmbeddedSources";
        public static readonly Assembly ThisAssembly = typeof(TestMethodGenerator).Assembly;
        public const string GeneratedCodeHeader = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------";

        public static string? GetRootNamespace(this AnalyzerConfigOptionsProvider analyzerConfigOptionsProvider)
        {
            return analyzerConfigOptionsProvider.GlobalOptions.TryGetValue("build_property.rootnamespace", out string? rootNamespace) ? rootNamespace : null;
        }

        public static void CollectEmbeddedSources(this IncrementalGeneratorPostInitializationContext context, string name)
        {
            string prefix = $"{EmbeddedSourcePrefix}.{name}";
            foreach (string resourceName in ThisAssembly.GetManifestResourceNames())
            {
                if (!resourceName.StartsWith(prefix, StringComparison.Ordinal))
                    continue;

                string fileName = resourceName.Substring(prefix.Length + 1);
                int extensionIndex = fileName.LastIndexOf('.');
                if (extensionIndex < 0)
                    extensionIndex = fileName.Length;

                fileName = fileName.Insert(extensionIndex, ".generated");

                string content;
                using (Stream stream = ThisAssembly.GetManifestResourceStream(resourceName)!)
                {
                    using (TextReader reader = new StreamReader(stream))
                    {
                        content = reader.ReadToEnd();
                    }
                }

                context.AddSource(fileName, $@"{GeneratedCodeHeader}

{NormalizeEmbeddedSource(content)}");
            }
        }

        private static string NormalizeEmbeddedSource(string content)
        {
            SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(content);
            EmbeddedSourceNormalizationVisitor visitor = new EmbeddedSourceNormalizationVisitor();
            SyntaxNode normalizedNode = visitor.Visit(syntaxTree.GetRoot())!;
            string normalizedContent = normalizedNode.ToFullString();
            return normalizedContent;
        }

        private sealed class EmbeddedSourceNormalizationVisitor : CSharpSyntaxRewriter
        {
            public override SyntaxNode? VisitClassDeclaration(ClassDeclarationSyntax node) => node.WithAttributeLists(CreateAttributeLists(node, Annotation.All));

            public override SyntaxNode? VisitEnumDeclaration(EnumDeclarationSyntax node) => node.WithAttributeLists(CreateAttributeLists(node, Dibix.EnumerableExtensions.Create(Annotation.GeneratedCode)));

            private static SyntaxList<AttributeListSyntax> CreateAttributeLists(MemberDeclarationSyntax node, IEnumerable<Annotation> annotations)
            {
                IEnumerable<AttributeListSyntax> attributeLists = annotations.Select(x => SyntaxFactory.AttributeList(new SeparatedSyntaxList<AttributeSyntax>().Add(CreateAttribute(x.Name, x.Arguments)))
                                                                                                       .WithLeadingTrivia(SyntaxFactory.Whitespace(new string(' ', 4)))
                                                                                                       .WithTrailingTrivia(SyntaxFactory.EndOfLine(Environment.NewLine)))
                                                                             .Concat(node.AttributeLists);
                return new SyntaxList<AttributeListSyntax>(attributeLists);
            }

            private static AttributeSyntax CreateAttribute(string name, string? arguments)
            {
                AttributeArgumentListSyntax? argumentList = null;
                if (arguments != null)
                    argumentList = SyntaxFactory.ParseAttributeArgumentList(arguments);

                AttributeSyntax attribute = SyntaxFactory.Attribute(SyntaxFactory.ParseName(name), argumentList);
                return attribute;
            }
        }
    }
}